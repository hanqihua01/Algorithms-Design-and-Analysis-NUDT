#include "horseHamilton.h"

// route以数字表示步长的方式记录马的周游路线
std::vector<std::vector<int>> route;
// board以记录方向的方式表示马的周游路线
std::vector<std::vector<std::vector<int>>> board;
// direct表示马的移动方向
std::vector<std::vector<int>> direct = { {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1} };
// bnn表示n*n的棋盘下马的周游路线
const std::vector<std::vector<std::vector<int>>> b66 = {
	{{0,7},{7,6},{0,5},{5,0},{7,5},{6,5}},
	{{1,0},{6,1},{1,4},{1,7},{6,4},{4,5}},
	{{2,7},{3,0},{4,3},{1,0},{7,2},{6,3}},
	{{7,2},{6,7},{5,0},{4,2},{3,7},{4,6}},
	{{0,1},{3,0},{0,5},{0,5},{4,2},{5,3}},
	{{1,2},{1,3},{3,4},{4,1},{2,4},{3,4}}
};
const std::vector<std::vector<std::vector<int>>> b68 = {
	{{0,7},{0,6},{5,0},{5,0},{0,6},{6,0},{5,7},{5,6}},
	{{0,1},{6,1},{6,4},{0,4},{4,1},{4,1},{7,4},{4,5}},
	{{2,7},{3,0},{7,4},{2,7},{7,2},{1,4},{2,7},{3,6}},
	{{7,2},{6,2},{5,6},{4,6},{6,5},{6,7},{5,7},{6,3}},
	{{0,1},{3,0},{1,5},{0,3},{3,1},{0,3},{2,5},{3,5}},
	{{1,2},{2,3},{2,4},{4,2},{1,2},{1,4},{3,2},{3,4}}
};
const std::vector<std::vector<std::vector<int>>> b88 = {
	{{0,7},{7,6},{5,7},{0,5},{7,5},{5,0},{7,5},{6,5}},
	{{7,1},{1,6},{1,4},{6,1},{1,6},{1,4},{7,6},{4,5}},
	{{2,7},{3,6},{5,3},{3,7},{7,0},{1,3},{7,2},{6,3}},
	{{2,1},{7,3},{7,2},{2,0},{5,6},{2,0},{4,7},{6,3}},
	{{2,7},{3,6},{5,1},{0,7},{3,6},{4,3},{7,2},{4,3}},
	{{7,1},{7,6},{0,3},{2,3},{0,7},{7,4},{7,2},{3,6}},
	{{2,0},{3,0},{5,0},{2,5},{3,4},{5,0},{5,4},{5,3}},
	{{2,1},{1,3},{4,3},{4,1},{4,1},{3,1},{2,3},{4,3}}
};
const std::vector<std::vector<std::vector<int>>> b810 = {
	{{0,7},{0,6},{5,0},{0,5},{0,5},{6,5},{5,0},{0,5},{7,5},{6,5}},
	{{0,1},{1,6},{1,4},{1,4},{4,1},{1,4},{1,4},{1,0},{4,7},{6,4}},
	{{2,0},{3,6},{6,4},{6,5},{0,2},{0,6},{7,5},{6,7},{7,2},{4,3}},
	{{2,7},{1,7},{4,7},{6,0},{1,7},{7,5},{0,4},{5,4},{7,2},{3,5}},
	{{2,7},{6,2},{5,2},{1,7},{2,0},{4,1},{5,2},{1,3},{3,4},{6,3}},
	{{7,1},{3,6},{3,2},{3,6},{7,1},{3,5},{4,3},{0,7},{5,7},{6,3}},
	{{0,2},{3,0},{5,0},{1,5},{3,0},{5,0},{5,1},{0,5},{5,2},{5,4}},
	{{2,1},{1,3},{2,4},{4,1},{4,1},{1,3},{4,1},{4,1},{3,2},{3,4}}
};
const std::vector<std::vector<std::vector<int>>> b1010 = {
	{{0,7},{0,6},{7,5},{6,0},{0,5},{6,5},{7,5},{5,0},{7,5},{6,5}},
	{{1,0},{6,0},{1,4},{1,4},{1,7},{4,1},{1,4},{1,0},{7,6},{4,6}},
	{{2,0},{3,6},{4,2},{4,3},{0,2},{5,6},{7,6},{6,3},{7,2},{4,3}},
	{{0,2},{7,6},{4,6},{7,1},{7,0},{3,0},{0,4},{2,6},{2,7},{6,3}},
	{{2,7},{0,7},{5,4},{7,0},{2,6},{2,7},{4,2},{4,3},{6,4},{6,3}},
	{{2,1},{2,6},{5,3},{7,4},{5,3},{4,3},{2,6},{6,5},{6,2},{3,5}},
	{{7,1},{3,6},{3,1},{2,5},{7,3},{1,5},{3,5},{1,2},{7,2},{6,5}},
	{{2,7},{1,6},{6,7},{1,5},{1,3},{2,5},{6,2},{1,2},{7,6},{6,5}},
	{{2,0},{1,3},{5,0},{1,0},{5,0},{5,3},{5,0},{1,0},{5,2},{5,3}},
	{{2,1},{3,2},{4,1},{3,1},{4,1},{4,2},{4,1},{2,1},{4,2},{4,3}}
};
const std::vector<std::vector<std::vector<int>>> b1012 = {
	{{0,7},{0,6},{6,5},{0,5},{7,6},{0,5},{7,5},{0,5},{0,6},{0,5},{7,6},{6,5}},
	{{1,7},{1,6},{5,4},{1,4},{1,6},{1,4},{6,5},{1,4},{7,6},{1,4},{7,4},{6,4}},
	{{2,1},{3,2},{5,6},{2,6},{1,0},{5,3},{6,7},{2,3},{5,7},{2,0},{7,2},{6,3}},
	{{2,1},{3,6},{7,0},{2,1},{5,0},{5,2},{4,1},{2,5},{5,7},{6,3},{7,2},{4,3}},
	{{0,7},{2,6},{2,1},{7,1},{4,0},{1,2},{4,1},{3,5},{0,6},{3,5},{7,2},{6,3}},
	{{2,0},{0,7},{5,4},{6,3},{0,6},{1,6},{4,5},{1,6},{7,2},{3,6},{5,4},{6,3}},
	{{2,1},{3,6},{4,5},{7,4},{1,3},{0,6},{5,4},{2,0},{5,1},{0,7},{7,2},{6,3}},
	{{1,7},{7,6},{3,2},{2,5},{2,1},{6,7},{2,1},{7,4},{2,5},{4,3},{7,2},{6,4}},
	{{2,0},{1,0},{5,0},{5,0},{2,3},{5,0},{1,0},{5,0},{5,0},{5,0},{3,2},{5,3}},
	{{2,1},{3,1},{4,3},{4,1},{4,2},{4,1},{3,1},{4,1},{4,3},{4,1},{4,2},{4,3}}
};

// 填充棋盘函数
void fillBoard(const std::vector<std::vector<std::vector<int>>>& b, int x1, int y1, int x2, int y2, bool trans) {
	int h = x2 - x1 + 1;
	int w = y2 - y1 + 1;
	if (trans)
		for (int i = x1; i <= x2; i++)
			for (int j = y1; j <= y2; j++) {
				// 如果board方向和b的方向不一致，则转换方向，利用相反反向在direct数组下标之和为7
				board[i][j][0] = 7 - b[j - y1][i - x1][0];
				board[i][j][0] = 7 - b[j - y1][i - x1][1];
			}
	else
		for (int i = x1; i <= x2; i++)
			for (int j = y1; j <= y2; j++) {
				// 如果board方向和b方向一致，则直接填充
				board[i][j][0] = b[i - x1][j - y1][0];
				board[i][j][1] = b[i - x1][j - y1][1];
			}
}

void combineBoard(int x1, int y1, int x2, int y2) {
	int dh = (x2 - x1 + 1) / 4 * 2 + (x2 - x1 + 1) % 2;
	int dw = (y2 - y1 + 1) / 4 * 2 + (y2 - y1 + 1) % 2;
	// 将相邻的两个棋盘进行连通
	if (board[x1 + dh][y1 + dw - 1][0] == 6) board[x1 + dh][y1 + dw - 1][0] = 4;
	else board[x1 + dh][y1 + dw - 1][1] = 4;
	if (board[x1 + dh + 2][y1 + dw - 2][0] == 2) board[x1 + dh + 2][y1 + dw - 2][0] = 1;
	else board[x1 + dh + 2][y1 + dw - 2][1] = 1;
	if (board[x1 + dh + 1][y1 + dw][0] == 1) board[x1 + dh + 1][y1 + dw][0] = 5;
	else board[x1 + dh + 1][y1 + dw][1] = 5;
	if (board[x1 + dh][y1 + dw + 2][0] == 5) board[x1 + dh][y1 + dw + 2][0] = 4;
	else board[x1 + dh][y1 + dw + 2][1] = 4;
	if (board[x1 + dh - 1][y1 + dw][0] == 2) board[x1 + dh - 1][y1 + dw][0] = 0;
	else board[x1 + dh - 1][y1 + dw][1] = 0;
	if (board[x1 + dh - 3][y1 + dw + 1][0] == 6) board[x1 + dh - 3][y1 + dw + 1][0] = 5;
	else board[x1 + dh - 3][y1 + dw + 1][1] = 5;
	if (board[x1 + dh - 2][y1 + dw - 1][0] == 5) board[x1 + dh - 2][y1 + dw - 1][0] = 1;
	else board[x1 + dh - 2][y1 + dw - 1][1] = 1;
	if (board[x1 + dh - 1][y1 + dw - 3][0] == 1) board[x1 + dh - 1][y1 + dw - 3][0] = 0;
	else board[x1 + dh - 1][y1 + dw - 3][1] = 0;
}

// 分治法主要函数
void divideConquer(int x1, int y1, int x2, int y2) {
	int h = x2 - x1 + 1; // h为棋盘高度
	int w = y2 - y1 + 1; // w为棋盘宽度
	int dh = h / 4 * 2 + h % 2; // dh为划分棋盘的高度
	int dw = w / 4 * 2 + w % 2; // dw为划分棋盘的宽度
	bool trans = false;
	if (h > w) { // 为方便处理，将所有棋盘变换为高比宽短
		trans = true;
		std::swap(h, w);
	}
	// 递归终止条件判断
	if (h == 6 && w == 6) {
		fillBoard(b66, x1, y1, x2, y2, trans); return;
	}
	if (h == 6 && w == 8) {
		fillBoard(b68, x1, y1, x2, y2, trans); return;
	}
	if (h == 8 && w == 8) {
		fillBoard(b88, x1, y1, x2, y2, trans); return;
	}
	if (h == 8 && w == 10) {
		fillBoard(b810, x1, y1, x2, y2, trans); return;
	}
	if (h == 10 && w == 10) {
		fillBoard(b1010, x1, y1, x2, y2, trans); return;
	}
	if (h == 10 && w == 12) {
		fillBoard(b1012, x1, y1, x2, y2, trans); return;
	}
	// 递归分治
	divideConquer(x1, y1, x1 + dh - 1, y1 + dw - 1);
	divideConquer(x1 + dh, y1, x2, y1 + dw - 1);
	divideConquer(x1, y1 + dw, x1 + dh - 1, y2);
	divideConquer(x1 + dh, y1 + dw, x2, y2);
	// 分治后合并棋盘
	combineBoard(x1, y1, x2, y2);
}


// 马的周游问题分治法解函数的定义
std::vector<std::vector<int>> horseHamilton(int m, int n, int sx, int sy) {
	// route以数字表示步长的方式记录马的周游路线
	route.assign(m, std::vector<int>(n, 0));
	// board以记录方向的方式表示马的周游路线
	for (int i = 0; i < m; i++) {
		std::vector<std::vector<int>> row;
		for (int j = 0; j < n; j++) {
			row.push_back(std::vector<int>(2, 0));
		}
		board.push_back(row);
	}
	// 进行分支求出马的周游路线
	divideConquer(0, 0, m - 1, n - 1);
	int i = --sx; int j = --sy;
	int step = 1;
	do {
		// 对route赋值，route的元素表示到底此位置的步数
		route[i][j] = step++;
		int a = i; int b = j;
		i += direct[board[a][b][0]][0];
		j += direct[board[a][b][0]][1];
		if (route[i][j] > 1) { // 如果已经访问过该点，则走另外一条路线
			i = a + direct[board[a][b][1]][0];
			j = b + direct[board[a][b][1]][1];
		}
	} while (i != sx || j != sy);
	return route;
}